Современные возможности ES-2015

Переменные let:
Видны только после объявления и только в текущем блоке.
Нельзя переобъявлять (в том же блоке).
При объявлении переменной в цикле for(let …) — она видна только в этом цикле.
Причём каждой итерации соответствует своя переменная let.

Переменная const — это константа, в остальном — как let.
Большинство переменных — константы в другом смысле: они не меняются после присвоения.
Но при разных запусках функции это значение может быть разным.
Для таких переменных можно использовать const и обычные строчные буквы в имени.


Деструктуризация массива:
Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

let [firstName, lastName] = ["Илья", "Кантор"];

// первый и второй элементы не нужны
let [, , title] = "Юлий Цезарь Император Рима".split(" ");

Оператор «spread»
let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" ");


let [firstName, lastName] = [];// присвоит undefined

// значения по умолчанию
let [firstName="Гость", lastName="Анонимный"] = [];

defaultLastName() для генерации значения по умолчанию будет осуществлён только при необходимости,
то есть если значения нет в массиве.
function defaultLastName() {//выражение, которое будет использовано, если значение отсутствует в массиве(не указано или undefined).
  return Date.now();
}

let [firstName, lastName=defaultLastName()] = ["Вася"];



Деструктуризация объекта:

let options = {
  title: "Меню"
};

let {width:w=100, height:h=200, title} = options;// ':' присвоить в переменную c именем. '=' значение по умолчанию.

В JavaScript, если в основном потоке кода (не внутри другого выражения) встречается {...}, то это воспринимается как блок.
в данном случае это создаст проблему при деструктуризации:

let a, b;
{a, b} = {a:5, b:6}; // будет ошибка, оно посчитает, что {a,b} - блок

Чтобы избежать интерпретации {a, b} как блока, нужно обернуть всё присваивание в скобки:
let a, b;
({a, b} = {a:5, b:6}); // внутри выражения это уже не блок

Вложенные объекты и массивы тоже работают, при деструктуризации нужно лишь сохранить ту же структуру, что и исходный объект/массив.
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Пончик", "Пирожное"]
}

let { title="Меню", size: {width, height}, items: [item1, item2] } = options;


деструктуризации особенно удобны при чтении объектных параметров функций.



Основные улучшения в функциях:

    Можно задавать параметры по умолчанию (могут быть не только значениями, но и выражениями. используются при отсутствующем аргументе или равном undefined)
    Оператор spread (троеточие) в объявлении позволяет функции получать оставшиеся аргументы в массив: function f(arg1, arg2, ...rest).

    передачи массива параметров как списка.(вместо apply)
    let numbers = [2, 3, 15];
    let max = Math.max(...numbers);

    деструктуризация для чтения приходящего объекта.
    let options = {
       title: "Меню"
    };

    function showMenu({title="Заголовок", width:w=100} = {}) {//ecли обьект options не передаем, нужно указать по умолчанию {}
       alert(`${title} ${w} ${h}`);
    }
    showMenu(options);

    У функции есть свойство name, оно содержит имя, указанное при объявлении функции, либо, если его нет, то имя свойства или переменную, в которую она записана.
    Есть и некоторые другие ситуации, в которых интерпретатор подставляет «самое подходящее» имя.

    Объявление Function Declaration в блоке {...} видно только в этом блоке.
    if (true) {
      sayHi(); // работает
      function sayHi() {
        alert("Привет!");
      }

    }
    sayHi(); // ошибка, функции не существует


    Появились функции-стрелки:
        Без фигурных скобок возвращают выражение expr: (args) => expr.
        С фигурными скобками требуют явного return.
        Не имеют своих this и arguments, при обращении получают их из окружающего контекста.
    Поиск this в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании.
        Не могут быть использованы как конструкторы, с new.

    Cохранение внешнего this и arguments удобно использовать для форвардинга вызовов и создания декораторов.
    function wrapper(f, ms) {
      return function() {
        setTimeout(() => f.apply(this, arguments), ms)
      }
    }
    function show(who) {
      alert(who);
    }
    let show2ms = wrapper(show, 2);
    show2ms('вася');



Строки:
Строки-шаблоны — для удобного задания строк (многострочных, с переменными), плюс возможность использовать функцию шаблонизации для самостоятельного форматирования.

${…} такую вставку называют «интерполяцией».

function f(strings, ...values) {// array  array
  alert(strings[0]);
  alert(JSON.stringify(strings));     // ["Sum of "," + "," =\n ","!"]
  alert(JSON.stringify(strings.raw)); // ["Sum of "," + "," =\\n ","!"]
  alert(JSON.stringify(values));      // [3,5,8]
  return(strings[1]);//функции шаблонизации не обязательно возвращать именно строку
}

let apples = 3;
let oranges = 5;

//          |  s[0] | v[0] |s[1]| v[1]  |s[2]  |      v[2]      |s[3]
let str = f`Sum of ${apples} + ${oranges} =\n ${apples + oranges}!`;
alert(str);


Улучшена поддержка юникода
Юникод — улучшена работа с суррогатными парами.
Внутренняя кодировка строк в JavaScript — это UTF-16, то есть под каждый символ отводится ровно два байта.
Но под всевозможные символы всех языков мира 2 байт не хватает.
Поэтому бывает так, что одному символу языка соответствует два юникодных символа (итого 4 байта).
Такое сочетание называют «суррогатной парой».

alert( String.fromCodePoint(119987) ); // ??
alert( '??'.codePointAt(0) ); // 119987

В JavaScript-строках давно можно вставлять символы по Unicode-коду, вот так:
\u{длинный код}
четырёхзначный шестнадцатиричный код, причём он должен быть ровно четырёхзначным.
alert( "\u2033" ); // ?, символ двойного штриха

Unicode-нормализация
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

Добавлены ряд полезных методов общего назначения:

    str.includes(s) — проверяет, включает ли одна строка в себя другую, возвращает true/false.
    str.endsWith(s) — возвращает true, если строка str заканчивается подстрокой s.
    str.startsWith(s) — возвращает true, если строка str начинается со строки s.
    str.repeat(times) — повторяет строку str times раз.



Объекты и прототипы


//Короткое свойство
let name = "Вася";
let user = {
  name,
};
alert( JSON.stringify(user) );//name:'Вася'

//Вычисляемое свойство
let name = "firstName";
let user = {
  [name]: 'Вася'
};
alert(JSON.stringify(user) );//firstName: 'Вася'


//Геттер-сеттер для прототипа
В ES5 для прототипа был метод-геттер:
    Object.getPrototypeOf(obj)
В ES-2015 также добавился сеттер:
    Object.setPrototypeOf(obj, newProto)
А также «узаконено» свойство __proto__, которое даёт прямой доступ к прототипу

Метод Object.assign(target, src1, src2...) — копирует свойства из всех аргументов в первый объект.
Метод Object.is(value1, value2) проверяет два значения на равенство. В отличие от === считает +0 и -0 разными числами. А также считает, что NaN равно самому себе.

//Методы объекта
Более короткий синтаксис объявления.
Наличие в методах специального внутреннего свойства [[HomeObject]] («домашний объект»), ссылающегося на объект, которому метод принадлежит.
Свойство [[HomeObject]] — не изменяемое
При создании метода — он привязан к своему объекту навсегда. Технически можно даже скопировать его и запустить отдельно, и super продолжит работать:

//super предназначено только для использования в методах объекта.
Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа.
При обращении через super используется [[HomeObject]] текущего метода, и от него берётся __proto__. Поэтому super работает только внутри методов.
Исключением из этого правила являются функции-стрелки. В них используется super внешней функции.

Object.setPrototypeOf(obj, proto) — метод для установки прототипа.
obj.__proto__ — ссылка на прототип.

let name = "Вася";
let surname = "Петров";
let methodName = "sayHi";

let parent = {
  get fullname() {
    return `${name} ${surname}`;
  }
};

let user = {
  __proto__: parent,
  name,
  surname,
  [methodName]() {// метод с вычисляемым названием
    return(`Hello ${name}`)
  },
}

alert(user.sayHi());
alert(user.fullname);



Тип данных Symbol
    Символы — новый примитивный тип, предназначенный для уникальных идентификаторов.
    Основная область использования символов — это системные свойства объектов, которые задают разные аспекты их поведения.
    Все символы уникальны, символы с одинаковым именем не равны друг другу.

    при создании "new" не используется так как это — примитив.
    let sym = Symbol("name");// необязательный аргумент «имя символа». Можно его использовать для описания символа, в целях отладки
    alert( sym.toString() ); // Symbol(name)
    alert( typeof sym ); // symbol

    Существует глобальный реестр символов, доступных через метод Symbol.for(name).
    let name = Symbol.for("name");//Для чтения (или создания, при отсутствии) «глобального» символа, если символ не глобальный возвращает undefined
    Для глобального символа можно получить его имя вызовом и Symbol.keyFor(sym).
    let name = Symbol.for("name");

    получить все символы обьекта, заметим что старая функция getOwnPropertyNames символы не возвращает
    Object.getOwnPropertySymbols

Нельзя просто взять и зарезервировать какие-то свойства существующих объектов для нового функционала.
Поэтому ввели целый тип «символы». Их можно использовать для задания таких свойств, так как они:
    а) уникальны,
    б) не участвуют в циклах,
    в) заведомо не сломают старый код, который о них слыхом не слыхивал.

Системные символы доступны как свойства функции Symbol, например Symbol.iterator.

Основная область использования символов — это системные свойства объектов, которые задают разные аспекты их поведения.
Поддержка у них пока небольшая, но она растёт.
Системные символы позволяют разработчикам стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.
Их список есть в спецификации, в таблице Well-known Symbols.

let isAdmin = Symbol("isAdmin");//Символы можно использовать в качестве имён для свойств объекта
let user = {
  name: "Вася",
  [isAdmin]: true,//не участвует в итерации
  [Symbol.for('admin')]: true//не участвует в итерации
};
alert(`${user.isAdmin} ${user.admin}`); //undefined undefined
alert(user[isAdmin]); //true
//alert(user[admin]); //error
alert(user[Symbol.for('admin')]); //true
alert( Object.keys(user) ); // name, age в цикле for..in также не будет символа
alert( user[Symbol.for("Admin")] );// доступ к свойству через глобальный символ — работает




Class:
Новая конструкция class — удобный «синтаксический сахар» для задания конструктора вместе с прототипом.
class Название [extends Родитель]  {
  constructor
  методы
}

Функция constructor запускается при создании new User, остальные методы записываются в User.prototype.
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    alert(this.name);
  }
}
let user = new User("Вася");
user.sayHi(); // Вася
    User нельзя вызывать без new, будет ошибка.
    Объявление класса с точки зрения области видимости ведёт себя как let.
    В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления).

    Методы, объявленные внутри class, также имеют ряд особенностей:

    Метод sayHi является именно методом, то есть имеет доступ к super, используя [[HomeObject]].
    Все методы класса работают в строгом режиме use strict, даже если он не указан.
    Все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет.


Class Expression:
let Person = class {// если = class User (Named Class Expression), User будет доступно только внутри класса, использовать для создания новых объектов данного типа.
  sayHi() { alert('Привет!'); }
};

new User().sayHi();




Геттеры, сеттеры и вычисляемые свойства, статические свойства.

В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через get/set, а также использовать […] для свойств с вычисляемыми именами:
class не позволяет задавать свойства-значения

class User {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  static get elemClass() {//статическими удобно делать константы User.elemClass
    return "menu"
  }

  static createGuest() {//используются как альтернативные варианты конструктора
    return new User("Гость", "Сайта");
  }

  // геттер
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }

  // сеттер
  set fullName(newValue) {
    [this.firstName, this.lastName] = newValue.split(' ');
  }

  // вычисляемое название метода
  ["test".toUpperCase()]() {
    alert("PASSED!");
  }
};

User.prototype.key = "value"//нет возможности задать в прототипе обычное значение (не функцию), такое как .
Конечно, никто не мешает после объявления класса в прототип дописать подобные свойства, однако предполагается, что в прототипе должны быть только методы.
Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.


Наследование.

class Animal { }
class Rabbit extends Animal { }

alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true
методы Rabbit находятся в Rabbit.prototype, методы Animal — в Animal.prototype, и они связаны через __proto__:

при переопределении метода родителя, вызов родительских методов — через super.method(...args).

constructor родителя наследуется автоматически. То есть, если в потомке не указан свой constructor, то используется родительский.
Если же у потомка свой constructor, то, чтобы в нём вызвать конструктор родителя — используется синтаксис super(...args).

Вызвать конструктор родителя можно только изнутри конструктора потомка. В частности, super() нельзя вызвать из произвольного метода.
В конструкторе потомка мы обязаны вызвать super() до обращения к this.



Итераторы:
Итерируемые или, иными словами, «перебираемые» объекты — это те, содержимое которых можно перебрать в цикле.
итераторы дают возможность сделать «перебираемыми» любые объекты.


for(let value of "Привет"){ alert(value) }//используется для перебора итерируемых или, иными словами, «перебираемых» объектов.

    Итератор — объект, предназначенный для перебора другого объекта.
    У итератора должен быть метод next(), возвращающий {done: Boolean, value: any}, где value — очередное значение, а done: true в конце.
    Метод Symbol.iterator предназначен для получения итератора из объекта. Цикл for..of делает это автоматически, но можно и вызвать его напрямую.
    В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством Symbol.iterator) объекты,оператор spread ...
    Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше.


Работа с массивом

for (property in object){ alert(value) }//используется для перебора обьекта.

[1,2,3].forEach((item, i, arr) => alert(item));//используется для перебора массива.
цикл for(var i=0; i<arr.length...) надёжнее и быстрее.

[1,2,3].map((item, i, arr) => i);//используется для трансформации массива.

[1,2,3].filter((item, i, arr) => item > 1);//используется для фильтрации массива через функцию.

[1,-2,3].every((item) => item > 0); // true, если все положительные

[-1,-2,3].some((item) => item > 0); // true, есть хоть одно положительное

arr.length - не количество элементов массива, а последний индекс + 1.

//для каждого элемента массива запустить функцию, промежуточный результат передавать первым аргументом далее
reduce((previousValue, currentItem, index, arr) => previousValue + currentItem, 0);

    push/pop, shift/unshift, splice — для добавления и удаления элементов.
    join/split — для преобразования строки в массив и обратно.
    slice — копирует участок массива.
    sort — для сортировки массива. Если не передать функцию сравнения — сортирует элементы как строки.
    reverse — меняет порядок элементов на обратный.
    concat — объединяет массивы.
    indexOf/lastIndexOf — возвращают позицию элемента в массиве (не поддерживается в IE8-).



Set, Map, WeakSet и WeakMap

Map — коллекция записей вида ключ: значение, лучше Object тем, что перебирает всегда в порядке вставки и допускает любые типы ключей.

Для итерации по map используется один из трёх методов:
    map.keys() — возвращает итерируемый объект для ключей,
    map.values() — возвращает итерируемый объект для значений,
    map.entries() — возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of.

для сохранения и чтения значений используются методы
    map.get(1);
    map.set(1,'num2').set('1', 'str2');Метод set можно чейнить:
    map.size хранит общее количество записей в map

Методы для удаления записей:
    map.delete(key) удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.
    map.clear() — удаляет все записи, очищает map.

Для проверки существования ключа:
    map.has(key) — возвращает true, если ключ есть, иначе false.


Set — коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. также допускает любые ключи

    set.add(item) — добавляет в коллекцию item, возвращает set (чейнится).
    set.delete(item) — удаляет item из коллекции, возвращает true, если он там был, иначе false.
    set.has(item) — возвращает true, если item есть в коллекции, иначе false.
    set.clear() — очищает set.

Перебор Set осуществляется через forEach или for..of аналогично Map:


WeakMap и WeakSet - Если поместить данные в WeakMap, а ключом сделать объект, то они будут автоматически удалены из памяти, когда удалится ключ(обьект).
    Нет свойства size.
    Нельзя перебрать элементы итератором или forEach.
    Нет метода clear().

WeakMap работает только на запись (set, delete) и чтение (get, has) элементов по конкретному ключу,
а не как полноценная коллекция. Нельзя вывести всё содержимое WeakMap, нет соответствующих методов.
Они не препятствуют сборке мусора, то есть если ссылка на объект осталась только в WeakSet/WeakMap — он будет удалён.




Модули export import

Современный стандарт описывает, как организовать код в модули, экспортировать и импортировать значения.

Экспорт:
    export можно поставить прямо перед объявлением функции, класса, переменной.
    Если export стоит отдельно от объявления, то значения в нём указываются в фигурных скобках: export {…}.
    Также можно экспортировать «значение по умолчанию» при помощи export default.

Импорт:
    В фигурных скобках указываются значения, а затем — модуль, откуда их брать: import {a, b, c as d} from "module".
    Можно импортировать все значения в виде объекта при помощи import * as obj from "module".
    Без фигурных скобок будет импортировано «значение по умолчанию»: import User from "user".



Proxy:

let proxy = new Proxy(target, handler);

target — объект, обращения к которому надо перехватывать.
handler — объект с «ловушками»: функциями-перехватчиками для операций к target.

Proxy позволяет модифицировать поведение объекта как угодно, перехватывать любые обращения к его свойствам и методам, включая вызовы для функций.
Особенно приятна возможность перехватывать обращения к отсутствующим свойствам, разработчики ожидали её уже давно.




Promise:

Promise — это специальный объект, который содержит своё состояние.текущий результат (если есть) и коллбэки.
состояние вначале pending («ожидание»), затем — одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
После вызова resolve/reject промис уже не может «передумать».принимает сосотояние и не изменяет его.Последующие вызовы resolve/reject игнорируются.

    1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
    2. Внешний код, получив promise, навешивает на него обработчики.
    3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой).
    При этом автоматически вызываются соответствующие обработчики во внешнем коде.
    функция обработчик принимает только один аргумент результат/ошибку, остальные игнорируются.


у объекта promise есть четыре внутренних свойства:
    PromiseState — состояние, вначале «pending».
    PromiseResult — результат, при создании значения нет.
    PromiseFulfillReactions — список функций-обработчиков успешного выполнения.
    PromiseRejectReactions — список функций-обработчиков ошибки.
Когда функция-executor вызывает reject или resolve, то PromiseState становится "resolved" или "rejected",
а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь "PromiseJobs".


Обработчики назначаются вызовом .then/catch   .catch - сокращённая запись .then(null, onRejected)
    Если PromiseState == "pending", то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.
    Иначе обработчики сразу помещаются в очередь на выполнение.
    Здесь важно, что обработчики можно добавлять в любой момент.
    Можно до выполнения промиса (они подождут), а можно — после (выполнятся в ближайшее время, через асинхронную очередь).


При возникновении ошибки — она отправляется в ближайший обработчик onRejected.
Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).
Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).

Если один из обработчиков не указан, .then добавляет его «от себя», следующим образом:
    Для успешного выполнения — функция Identity, которая выглядит как arg => return arg, то есть возвращает аргумент без изменений.
    Для ошибки — функция Thrower, которая выглядит как arg => throw arg, то есть генерирует ошибку.
    Thrower — это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.

Промисификация — это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.

var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически
  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})


Цепочки промисов - «Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов — пожалуй, основная причина,
из-за которой существуют и активно используются промисы.

promise "чейнинг" - передает результат (значение, промис, или throw error) в следующий обработчик
.then(response => new Promise(...) )//Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
.then(response => {name: 'test'})
.then(arg => return arg, arg => throw arg)// по умолчанию если обработчик не указан
.catch(err => console.log(err));

если не чейнить
promise.then(res)//создаётся новый промис, даёт свою ветку выполнения


Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся,
и переходит в состояние «выполнено» с массивом их результатов.
Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.

Promise.resolve(value) - аналогичен конструкции  new Promise((resolve) => resolve(value));

Promise.reject(error) - Promise.reject(new Error("...")).catch(alert);

Promise.race(iterable) - результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.





Генераторы:

Для объявления генератора используется новая синтаксическая конструкция: function* (функция со звёздочкой).
Её называют «функция-генератор» (generator function).

При запуске, код такой функции не выполняется. Вместо этого она возвращает специальный объект, который как раз и называют «генератором».
let generator = generateSequence();//При создании генератора код находится в начале своего выполнения.

Основным методом генератора является next(), выполнение кода до ближайшего ключевого слова yield, значение — возвращается во внешний код

ответ: {value: 2, done: false/true}
После done: true, Новые вызовы generator.next(), не вызовут ошибки, будут возвращать один и тот же объект: {done: true}.

Генератор — итератор можно перебирать и через for..of, результат return в цикле for..of не выводится.

yield — дорога в обе стороны
Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.
Вызов let result = yield value делает следующее:
    Возвращает value во внешний код, приостанавливая выполнение генератора.
    Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
    Генератор продолжит выполнение, аргумент next будет возвращён как результат yield (и записан в result).


generator.throw(err) для того, чтобы передать в yield ошибку. При этом на строке с yield возникает исключение.
Если ошибку не перехватить внутри генератора, то она «выпадет» из генератора. По стеку в ближайший вызов, который инициировал выполнение, можно перехватить её там


Генераторы позволяют писать плоский асинхронный код, при помощи библиотки co.
Плоский асинхронный код
    Генератор yield'ит не просто значения, а промисы.
    Есть специальная «функция-чернорабочий» execute(generator) которая запускает генератор, последовательными вызовами next получает из него промисы — один за другим,
    и, когда очередной промис выполнится, возвращает его результат в генератор следующим next.
    Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат — например, возвращает через промис куда-то ещё,
    во внешний код или просто использует.


Библиотека «co»
Библиотека co, как и execute в примере выше, получает генератор и выполняет его.

Есть несколько видов значений, которые можно yield, и их обработает co:
    Промис.
    Объект-генератор.
    Функция-генератор function*() — co её выполнит, затем выполнит полученный генератор.
    Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и результат, в той же структуре, будет выдан наружу.


co - композиция генераторов

Композиция — встраивание одного генератора в поток другого. значения из вложенного генератора выдаются «по мере готовности».
Поэтому она будет работать даже если поток данных из вложенного генератора оказался бесконечным или ожидает какого-либо условия для завершения.

при запуске вложенных генераторов используем yield*
yield* - исполняется в потоке внешнего генератора
Делегирование генераторов yield* — это встроенный механизм JavaScript.
делегирование генераторов сохраняет стек.
Переменные вложенного генератора не попадают во внешний, «делегирование» только выводит результаты yield* во внешний поток.
Поскольку не происходит лишних вызовов, это быстрее по производительности.

co(function*() {
  let result = yield* gen();
  alert(result); // hello

  //gen() и затем gen2 встраиваются во внешний генератор
  //Это — отличный вариант для библиотеки co. Композиция yield* gen() вызывает gen() в потоке внешнего генератора. Аналогично делает и yield* gen().
  //Поэтому yield new Promise из строки (1) в gen2() попадает напрямую в библиотеку co, как если бы он был сделан так:
  let result = yield new Promise(
    resolve => setTimeout(resolve, 1000, 'hello')
  );
}).then(alert); // возвращает промис с результатом генератора.
.catch(alert); // Даже если результата нет, ошибки нужно обработать через catch, иначе они «подвиснут» в промисе.

function* gen() {
  return yield* gen2();
}
function* gen2() {
  let result = yield new Promise( // (1)
    resolve => setTimeout(resolve, 1000, 'hello')
  );
  return result;
}




Замыкания

«Понимать замыкания» в JavaScript означает понимать следующие вещи:
1 Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект.
  На верхнем уровне им является “глобальный объект”, в браузере — window.
2 При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
3 При вызове функции, куда бы её ни передали в коде — она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего “рождения”.

Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.

При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.
Такие функции не могут использовать замыкание

function makeCounter() {
  var currentCount = 1;//защищенное
  //counter.currentCount = 1;//публичное
  // возвращаемся к функции
  function counter() {
      return currentCount++;
    }
  // ...и добавляем ей методы!
  counter.set = function(value) {
    currentCount = value;
  };
  counter.reset = function() {
    currentCount = 1;
  };
  return counter;
}


Модуль при помощи замыканий — это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.
Но снаружи программист, использующий модуль, может обращаться напрямую только к тем, которые экспортированы.
Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.



ООП в прототипном стиле




ООП в функциональном стиле

Функциональное наследование
https://learn.javascript.ru/functional-inheritance
способ наследования, описанный в этой главе, используется нечасто.

Внутренний и внешний интерфейс
Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.
Свойства, записанные в this, можно считать публичными.
При обращении к приватному методу внутри конструктора, this = undefined
Можно при объявлении функции привязать контекст через bind.
var getBoilTime = function() {
  return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power;
}.bind(this);

или сохранить this в замыкании
предварительно скопировать this во вспомогательную переменную и обращаться из внутренних функций уже к ней.
var self = this;
function getBoilTime() {
  return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power;
}
При наличии чётко выделенного внешнего интерфейса, разработчик может свободно менять внутренние свойства и методы, без оглядки на коллег.



Геттеры и сеттеры

Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют “сеттер” (setter method).
Если свойство предназначено только для чтения, то может быть только геттер, только для записи — только сеттер.
качестве альтернативы паре геттер/сеттер применяют единую функцию, которая без аргументов ведёт себя как геттер, а с аргументом — как сеттер.
Также можно организовать геттеры/сеттеры для свойства, не меняя структуры кода, через дескрипторы свойств.


Скрипты
оба загружаются асинхронно.
<script src="1.js" async></script>//async первым сработает тот скрипт, который раньше загрузится:
<script src="2.js" async></script>
<script src="1.js" defer></script>//defer относительный порядок скриптов с будет сохранён.
<script src="2.js" defer></script>



Формат JSON, метод toJSON

JSON.parse — читает объекты из строки в формате JSON.
Для интеллектуального восстановления из строки у JSON.parse(str, reviver) есть второй параметр reviver, который является функцией function(key, value).
Если она указана, то в процессе чтения объекта из строки JSON.parse передаёт ей по очереди все создаваемые пары ключ-значение
и может возвратить либо преобразованное значение, либо undefined, если его нужно пропустить.

JSON.stringify — превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.
При сериализации объекта вызывается его метод toJSON.
JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации.
JSON.stringify(value, replacer, space) есть ещё третий параметр space.
Если он является числом — то уровни вложенности в JSON оформляются указанным количеством пробелов, если строкой — вставляется эта строка.
можно передать функцию function(key, value), которая возвращает сериализованное value либо undefined, если его не нужно включать в результат


try..catch

при ошибке в try скрипт не “падает”, и мы получаем возможность обработать ошибку внутри catch.
try..catch работает только в синхронном коде
Ошибку, которая произойдёт в коде, запланированном “на будущее” или колбеке, например, в setTimeout, try..catch не поймает:


Оператор throw <объект ошибки>. генерирует ошибку.
Проброс исключения
Ошибку, о которой catch не знает, он не должен обрабатывать.
Такая техника называется “проброс исключения”: в catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e.
При этом ошибка “выпадает” из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо “повалит” скрипт.

Секция finally не обязательна, но если она есть, то она выполняется всегда:

В window.onerror можно присвоить функцию, которая выполнится при любой “выпавшей” из скрипта ошибке.




setTimeout и setInterval
возвращают идентификатор таймера.
В браузере по умолчанию минимальная задержка по стандарту составляет 4мс, для не подвисания
Важная альтернатива setInterval — рекурсивный setTimeout:
Рекурсивный setTimeout — более гибкий метод тайминга, чем setInterval,
так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего.
Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval — нет.
Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.
При рекурсивном setTimeout задержка всегда фиксирована и равна 100мс.

При передаче функции в setInterval/setTimeout создаётся внутренняя ссылка на неё, через которую браузер её будет запускать
    Для setTimeout — внутренняя ссылка исчезнет после исполнения функции.
    Для setInterval — ссылка исчезнет при очистке таймера.
Так как функция также тянет за собой всё замыкание, то ставшие неактуальными, не отменённые setInterval могут приводить к излишним тратам памяти.





5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип — объекты object.
typeof undefined // "undefined"
typeof 0 // "number"
typeof true // "boolean"
typeof "foo" // "string"
typeof {} // "object"
alert( typeof [] ); // 'object'
alert( typeof new Date ); // 'object'
typeof null // "object"  (1)
typeof function(){} // "function"  (2)
при присваивании переменных копируются целиком или, как говорят, «по значению».


Для проверки типа на массив есть специальный метод: Array.isArray(arr). Он возвращает true только если arr

Во всех встроенных объектах есть специальное свойство [[Class]], в котором хранится информация о его типе или конструкторе.
Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта Object, другая не подойдёт.
function getClass(obj) {
  return {}.toString.call(obj).slice(8, -1);
}
alert( getClass(new Date) ); // Date
alert( getClass([1, 2, 3]) ); // Array




Преобразования примитивов

числа
Преобразование к числу, унарный плюс +
alert( +"2" + +"3" ); // 5, число, оба операнда предварительно преобразованы в числа
В JavaScript существует числовое значение бесконечность Infinity.больше любого числа.Деление на ноль, Infinity
Ошибка вычислений дает NaN.(Not-A-Number).Значение NaN можно проверить специальной функцией isNaN(n),
преобразует аргумент к числу и возвращает true если NaN или false.
parseInt и ее аналог parseFloat преобразуют строку которые начинаются с числа, пока это возможно.
ФункцияisFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.
Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор.
Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p.
Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.
лучайные числа от 0 до 1 генерируются с помощью Math.random(), остальные — преобразованием из них.
undefined в NaN
null в 0

Сравнение разных типов — значит численное преобразование:
alert( "\n0 " == 0 ); // true
alert( "\n" == false );// true
alert( "1" == true );// true

Значение null не является «ссылкой на нулевой адрес/объект» или чем-то подобным. Это просто специальное значение.
Значение undefined означает «переменная не присвоена».


строки
Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
alert( '1' + 2 ); // "12"
приведение к строке — особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.
alert( 2 - '1' ); // 1
"".charAt(0) // пустая строка
""[0] ) // undefined
indexOf возвращает позицию, на которой находится подстрока или -1, если ничего не найдено
substr, substring, slice - Взятие подстроки.(предпочтителен slice)
trim обрезает пробелы с начала и конца строки.
Строки сравниваются побуквенно. буквы сравниваются по их кодам.

преобразование к логическому типу

Оператор if (...) вычисляет и преобразует выражение в скобках к логическому типу.
Число 0, пустая строка "", null, undefined, NaN являются false,
Остальные значения, любые объекты — true.

двойное НЕ используют для преобразования значений к логическому типу:
alert( !!"строка" ); // true
alert( !!null ); // false

логические операторы
|| запинается на «правде»,
&& запинается на «лжи».
используют, в частности, чтобы выбрать первое ||истинное, &&ложное значение из списка

Если все значения «ложные», то || возвратит последнее из них:
alert( undefined || '' || false || 0 ); // 0


Преобразование объектов
При строковом преобразовании объекта используется его метод toString. Он должен возвращать примитивное значение, причём не обязательно именно строку.
Для численного преобразования используется метод valueOf, который также может возвратить любое примитивное значение.
У большинства объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString.


Сравнение примитивов

При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.
alert( '2' > 1 ); // true, сравнивается как 2 > 1
alert( '01' == 1 ); // true, сравнивается как 1 == 1
alert( false == 0 ); // true, false становится числом 0
alert( true == 1 ); // true, так как true становится числом 1.

Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.
Если тип разный, то они всегда возвращают false:

Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё.
При преобразовании в число null становится 0, а undefined становится NaN.
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.

Сравнение === проверяет точное равенство, включая одинаковый тип. Это самый очевидный и надёжный способ сравнения.
Остальные сравнения == < <= > >= осуществляют числовое приведение типа:
Они равны null == undefined друг другу и не равны ничему ещё. В частности, не равны нулю.
В других сравнениях (кроме ===) значение null преобразуется к нулю, а undefined — становится NaN («ошибка»).




Инкремент/декремент
можно применить только к переменной. Код 5++ даст ошибку.
Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
var i = 1;
alert( 2 * ++i ); // 4

var i = 1;
alert( 2 * i++ ); // 2, выполнился раньше но значение вернул старое



Циклы

Прерывание цикла: break
Следующая итерация: continue
While — проверка условия перед каждым выполнением.
do..while — проверка условия после каждого выполнения.
for — проверка условия перед каждым выполнением, а также дополнительные настройки.

Любое объявление переменной срабатывает один раз и распространяется на всю функцию.
Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.
Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'.

Конструкция switch
Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.




Функции

Function Declaration — функция, объявленная в основном потоке кода.
Function Expression — объявление функции в контексте какого-либо выражения, например присваивания.
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Функцию можно вызвать с любым количеством аргументов.
Если параметр не передан при вызове — он считается равным undefined.
В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
в функции не должно быть ничего, кроме самого действия и поддействий, неразрывно связанных с ним.
Функцию можно скопировать в другую переменную
функция создаётся на лету вызовом new Function(params, code)
При запуске функции создаётся новый объект с переменными LexicalEnvironment(объект переменных).
Он получает ссылку на внешний объект переменных из [[Scope]](скрытое свойство функции).
Полный список аргументов, с которыми вызвана функция, доступен через arguments.
Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||. var a = a || 1;

В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию,
вместо работы с arguments организуют передачу данных через объект, который как правило называют options.
Возможен и гибридный подход, при котором первый аргумент обязателен, а второй — options, который содержит всевозможные дополнительные параметры:

(function( ) { // Это безымянная функция.
//создается свой LexicalEnvironment(объект переменных),  у скрипта была своя собственная область видимости.
// объявленные переменные станут свойствами объекта вызова, тем самым
// исключается вероятность конфликтов с глобальным пространством имен.
})(); // конец функционального литерала и его вызов.


Контекст вызова

Значение this называется контекстом вызова и будет определено в момент вызова функции.
Контекст this никак не привязан к функции, даже если она создана в объявлении объекта.
Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).

function sum(a) {
  var currentSum = a;
  function f(b) {
    console.log(b);
    currentSum += b;
    return f;
  }
  f.toString = function() {
    return currentSum;
  };
  return f;
}
console.log(sum(1)(3));
1 раз записывает в замыкание currentSum = 1 и возвращает ccылку на f,
2 раз вызывает f c параметром 3 и возращает также f



Рекурсия, контекст выполнения, стек.

У каждого вызова функции есть свой «контекст выполнения» (execution context)
Контекст выполнения — это служебная информация, которая соответствует текущему запуску функции.
Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных — «стеке контекстов».
контекст включает в себя не только переменные, но и место в коде, так что когда вложенный вызов завершится — можно будет легко вернуться назад.
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась.


Функция конструктор.

Конструктором становится любая функция, вызванная через new.
функция, запущенная через new, делает следующее:
    Создаётся новый пустой объект.
    Ключевое слово this получает ссылку на этот объект.
    Функция выполняется. Как правило, она модифицирует this, добавляет методы, свойства.
    Возвращается this.
первая и последняя строка — это то, что делает интерпретатор):
function Animal(name) {
  // this = {};

  // в this пишем свойства, методы
  this.name = name;
  this.canWalk = true;

  // return this;
}

вызов return с объектом вернёт объект, а с чем угодно, кроме объекта — возвратит, как обычно, this.
Те функции и данные, которые должны быть доступны для внешнего кода, мы пишем в this
а которые нужны только внутри самого объекта, сохраняем в локальной области видимости var.

Оператор создает новый пустой объект без каких либо свойств, После создания пустого объекта оператор new устанавливает в этом объекте ссылку на прототип,
а затем вызывает функцию, передавая ей только что созданный объект в виде значения ключевого слова this.
Прототипом объекта является значение свойства  prototype функции конструктора.
Любые свойства, добавленные к прототипу, автоматически становятся свойствами объектов, инициализируемых конструктором,
объект prototype наследует свойства от  Object.prototype. наследование свойств происходит только при чтении значений свойств, но не при их записи.

Литерал объекта – это заключенный в фигурные скобки список свойств (пар «имя–значение»), разделенных запятыми.



Работа с обьектами

Перечисление свойств
for(var prop in obj) {
    alert(prop);
}

Проверка существования свойств
if ("x" in o) o.x = 1;

обращении к несуществующему свойству возвращается значение  undefined
if (o.x !== undefined) o.x = 1;

Если свойство doSomething существует и не содержит значение null или undefined
if (o.doSomething) o.doSomething();

Узнать тип обьекта. Всегда вызывается метод по умолчанию toString()
Object.prototype.toString.apply(o);

Доступ к свойствам объекта
object.property - имя свойства представляет собой идентификатор
object["property"] - имя свойства представляет собой строку
customer["address" + i] + '\n';

Объекты: передача по ссылке

Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Фундаментальным отличием объектов от примитивов, является их хранение и копирование «по ссылке».
При копировании переменной с объектом — копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
Так как объект всего один, то изменения через любую переменную видны в других переменных:



Объекты как ассоциативные массивы

Объекты — это ассоциативные массивы с дополнительными возможностями
Ассоциативный массив — структура данных, в которой можно хранить любые данные в формате ключ-значение.

Проверка существования свойства с определенным ключом.
if ("name" in person) {
  alert( "Свойство name существует!" );
}

в JavaScript можно обратиться к любому свойству объекта, даже если его нет. Ошибки не будет.
Но если свойство не существует, то вернется специальное значение undefined:


Обьект перебор свойств?
Правда ли, что при переборе for(key in codes) ключи key будут перечислены именно в том порядке, в котором заданы?
По стандарту — нет. Но некоторое соглашение об этом, всё же, есть.
если имя свойства — нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались.
если имя свойства — число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.





Управление памятью в JavaScript

Определённое множество значений считается достижимым изначально, в частности:
Значения, ссылки на которые содержатся в стеке вызова, то есть — все локальные переменные и параметры функций,
которые в настоящий момент выполняются или находятся в ожидании окончания вложенного вызова.Все глобальные переменные.
Эти значения гарантированно хранятся в памяти. Мы будем называть их (корнями).

Любое другое значение сохраняется в памяти лишь до тех пор, пока доступно из корня по ссылке или цепочке ссылок.

Самая простая ситуация здесь с примитивами. При присвоении они копируются целиком, ссылок на них не создаётся,
так что если в переменной была одна строка, а её заменили на другую, то предыдущую можно смело выбросить.
Именно объекты требуют специального “сборщика мусора”, который наблюдает за ссылками,
так как на один объект может быть много ссылок из разных переменных и, при перезаписи одной из них, объект может быть всё ещё доступен из другой.

Сборщик мусора идёт от корня по ссылкам и запоминает все найденные объекты. По окончанию — он смотрит, какие объекты в нём отсутствуют и удаляет их.

Объект переменных внешней функции существует в памяти до тех пор, пока существует хоть одна внутренняя функция, ссылающаяся на него через свойство [[Scope]].
Обычно объект переменных удаляется по завершении работы функции. Даже если в нём есть объявление внутренней функции:

1)
function f() {
  var value = 123;

  function g() {} // g видна только изнутри
}

f();

В коде выше value и g являются свойствами объекта переменных.
Во время выполнения f() её объект переменных находится в текущем стеке выполнения, поэтому жив.
По окончанию, он станет недостижимым и будет убран из памяти вместе с остальными локальными переменными.

2)
function f() {
  var value = 123;
  function g() {}
  return g;
}
var g = f(); // функция g будет жить и сохранит ссылку на объект переменных

В скрытом свойстве g.[[Scope]] находится ссылка на объект переменных, в котором была создана g.
Поэтому этот объект переменных останется в памяти, а в нём — и value.
Объект LexicalEnvironment живёт ровно до тех пор, пока на него существуют ссылки.
g = null; //память будет очищена




Контекст вызова

Для доступа к текущему объекту из метода используется ключевое слово this.
Значением this является объект перед “точкой”, в контексте которого вызван метод
this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.

Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.
Значение this называется контекстом вызова и будет определено в момент вызова функции.

Значение this при вызове без контекста.
При этом this получает значение window, глобального объекта.
А в режиме use strict вместо глобального объекта this будет undefined.

Контекст this никак не привязан к функции, даже если она создана в объявлении объекта.
Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).

точка возвращает не функцию, а значение специального “ссылочного” типа Reference Type.
  base — как раз объект,
  name — имя свойства,
  trict — вспомогательный флаг для передачи use strict.

  Скобки () получают из base значение свойства name и вызывают в контексте base.
  Другие операторы получают из base значение свойства name и используют, а остальные компоненты игнорируют.




Call, apply
f.call(контекст, аргумент1, аргумент2, ...) — то же, что обычный вызов, но с явно указанным this(=context).
func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.
Вызов call/apply с null или undefined
В современном стандарте call/apply передают this “как есть”.
А в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window

При вызове функции как метода
    obj.func(...)    // this = obj
    obj["func"](...)

При обычном вызове
    func(...) // this = window (ES3) /undefined (ES5)

В new
    new func() // this = {} (новый объект)

Явное указание
    func.apply(context, args) // this = context (явная передача)
    func.call(context, arg1, arg2, ...)


“Одалживание метода”

function printArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную
  var argStr = join.call(arguments, ':');
}
printArgs(1, 2, 3);




Привязка контекста и карринг: “bind”

bind() возвращает “функцию-обёртку”(wrapper), вызывается таже функция но фиксированным контекстом.
Также можно указать аргументы, тогда и они будут фиксированы. Фиксированые аргументы встанут перед теми, которые указаны при вызове.

function bind(func, context) {
  return function() { // (*)
    return func.apply(context, arguments);
  };
}

Методы call/apply вызывают функцию с заданным контекстом и аргументами.
А bind не вызывает функцию. Он только возвращает “обёртку”, которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.
Привязать всё: bindAll

Карринг (currying) или каррирование — означает создание новой функции путём фиксирования аргументов существующей с помощью bind.
Фиксированые аргументы встанут перед теми, которые указаны при вызове.

Функции-обёртки, декораторы
Декоратор — приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.
новые возможности, которые можно “нацепить” на любую функцию.
function checkPermissionDecorator(f) {
  return function() {
    if (isAdmin()) {
      return f.apply(this, arguments);
    }
    alert( 'Недостаточно прав' );
  }
f.apply(this, arguments) Этот приём называется “форвардинг вызова”, текущий контекст и аргументы через apply передаются в функцию f,
так что изнутри f всё выглядит так, как была вызвана она напрямую, а не декоратор.





Обьекты как пространства имен

var flanagan; // Объявление единственного глобального имени "flanagan"
if (!flanagan) flanagan = {}; // Создается объект, если он еще не определен
flanagan.Class = {}           // Создается пространство имен flanagan.Class

Определение частного пространства имен с помощью замыкания
var com;
if (!com) com = {};
if (!com.davidflanagan) com.davidflanagan = {};









